# 1주차 (section1)

# 스프링 스터디 1주차 정리

---

## 스프링

### 스프링이란?

- 여러가지 기술들의 모음
    - 스프링 프레임워크(가장 핵심)
    - 스프링 부트(스프링을 편하게 사용하게 해줌, 전에는 세팅하는데도 엄청 어려웠음)
    - 스프링 세션
    - 스프링 데이터
    - 스프링 시큐리티
    - 등등등

### 스프링 프레임워크

- 스프링의 핵심
- 핵심 기술
    - 스프링 DI 컨테이너
    - AOP
    - 이벤트
- 웹 기술
    - 스프링 MVC
- 언어
    - 코틀린
    - 그루비

### 스프링 부트

- 스프링 프레임워크를 편리하게 사용하게 해줌
- 단독으로 실행 가능한 스프링 어플리케이션 생성
- Tomcat과 같은 웹 서버를 내장
- 스프링과 외부 라이브러리 자동 구성
- 간결한 설정

### 스프링의 핵심

- 자바 언어의 프레임워크
    
    → 자바 특징 : 객체 지향 언어 → 스프링은 좋은 객체 지향 애플리케이션을 만들수 있도록 도와주는 프레임워크
    

# 객체 지향 프로그래밍

<aside>
💬 여러 개의 독립된 단위, 즉 객체들의 모임으로 컴퓨터 프로그램을 파악하고 함

</aside>

- 각각의 객체는 메시지를 주고받고, 데이터를 처리할 수 있음(협력)
- 프로그램을 유연하고 변경이 용이하게 만듦

> 프로그램을 유연하고 변경이 용이하게?
> 
- 부품을 갈아 끼우듯이, 키보드, 마우스 갈아 끼우듯이

→ 객체지향의 핵심 : **다형성**

### 다형성

- 실세계 비유
    - 역할과 구현으로 세상을 구분
        
        <img width="1067" alt="%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-04-08_20 13 44" src="https://github.com/SOPT-34th-Spring-Study/spring-study/assets/70939232/920be69c-737f-4772-92ea-fc561c8bbee7">
        
    - 자동차 역할과 실제 자동차(k3, 아반떼 등등)으로 자동차 구현으로 나뉨 → 실제 자동차가 바뀌어도 운전자 역할은 영향이 안감
        - why? → 어짜피 운전할줄만 알면 어떤 차를 몰든 똑같기 때문!
    
    <aside>
    💬 즉, 유연하고 변경이 용이하다 - > 운전자 역할은 자동차 역할(인터페이스)만 알면 된다, 자동차가 바뀌는것에 영향을 안받음
    
    </aside>
    
    - 클라이언트에 영향을 주지 않고 새로운 기능을 제공가능
    - 클라이언트는 구현 대상 자체를 변경해도 영향 x
    - 클라이언트는 대상의 역할(인터페이스)만 알면 됨
    - 클라이언트는 구현 대상의 내부 구조, 내부 구조 변경사항을 몰라도 됨
    - 새로운 자동차가 나와도 클라이언트는 새로운 걸 안배워도 됨.
        - how? : 역할과 구현으로 구분했기 때문!

- 자바에서 역할과 구현 분리
    - 역할 : 인터페이스
    - 구현 : 인터페이스를 구현한 클래스, 구현 객체
    - 객체 설계 시, 역할과 구현을 명확히 분리
    - 인터페이스를 먼저 설계하고, 그 역할(인터페이스)에 맞는 구현 객체 만들기
    - 예시 사진
        
        <img width="1207" alt="%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-04-08_20 23 41" src="https://github.com/SOPT-34th-Spring-Study/spring-study/assets/70939232/e0ed343d-9510-4250-9c0c-5f9b02411ce1">
        
    
    - 파란색에서 빨간색을 바라보면 빨간 save호출, 초록색이면 초록 save호출

- 다형성의 본질
    - 인터페이스를 구현한 객체 인스턴스를 실행 시점에 유연하게 변경가능
    - **협력**이라는 객체 사이의 관계에서 시작해야함
    - 클라이언트를 변경하지 않고, 서버의 구현 기능을 유연하게 변경 가능
    - 확장 가능한 설계
- 한계
    - 역할(인터페이스)자체가 변하면, 클라, 서버 모두 변경해야함

### 다형성 정리

- **다형성이 가장 중요!!!**
- 스프링은 다형성을 극대화해서 이용할 수 있게 도와줌
- 스프링의 특징인 제어의역전(IOC), 의존관계 주입(DI)는 다형성을 활용해서 역할과 구현을 편리하게 다룰 수 있도로 ㄱ지원함

# SOLID 법칙

- 클린코드로 유명한 로버트 마틴이 정리한 좋은 객체 지향 설계의 원칙
- SRP : 단일 책임 원칙(single responsibility principle)
- OCP : 개방-폐쇄 원칙(Open/closed principle)
- LSP : 리스코프 치환 원칙(Liskov substitution principle)
- ISP : 인터페이스 분리 원칙(Interface segregation principle)
- DIP : 의존관계 역전 원칙(Dependency inversion principle)

### SRP(단일 책임 원칙)

- 한 클래스는 하나의 책임만 가짐
- 책임은 모호함
- → 중요한 기준은 변경
- 변경할 때, 파급 효과가 적으면 이 원칙을 잘 따른 것(ex. UI 변경, 객체 생성과 사용 분리)

### OCP(개방-폐쇄 원칙)

- 확장에는 열려있으나 변경에는 닫혀있어야 됨(이 말이 애매할 수 있음 → 다형성을 활용해야함)
- 다형성 활용
    - 다형성으로 인터페이스(or 클래스 상속관계)를 구현한 객체를 실행 시점에 유연하게 변경 가능
    - 위 사진들과 같이 역할과 구현을 분리해두면 구현은 다른 거로 땜빵이 가능 → 개방 폐쇄 원칙
    - 하지만 변경에 닫혀있어야 되는데?
        
        <img width="1215" alt="%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-04-08_20 37 36" src="https://github.com/SOPT-34th-Spring-Study/spring-study/assets/70939232/5f55a2c6-6edb-4d99-a185-6cc92169535b">
        
    - 여기서 변경을 할 때 닫혀있어야되는데 코드를 보면 코드 자체에 변경이 있음 → 문제
    - 문제점
        - MemberService 클라이언트가 클래스 직접 선택 → 구현 객체를 변경하려면 클라 코드를 바꿔야됨 → 다형성은 지켰지만 OCP 원칙 위반
        - 해결하려면? → 객체를 생성하고 연관관계를 맺어주는 별도의 조립, 설정자가 필요 → 그게 바로 스프링(스프링 컨테이너)
        - 그래서 OCP 원칙을 지키기 위해선 DI도 필요 IOC 컨테이너도 필요함
        

### LSP(리스코프 치환 원칙)

- 객체는 프로그램 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 함
- ex. 자동차 인터페이스의 엑셀은 앞으로 가는 기능인데 뒤로 가게 구현하면 이 원칙 위반

### ISP(인터페이스 분리 원칙)

- 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.
- ex.
    - 자동차 인터페이스 → 운전 인터페이스, 정비 인터페이스로 분리
    - 사용자 클라이언트 → 운전자 인터페이스, 정비사 인터페이스로 분리 가능
    - 분리하면 정비 인터페이스가 변경되어도 운전자 클라이언트에 영향 안줌
- 적당한 크기로 잘 나눠야함

### DIP(의존관계 역전 원칙)

- 프로그래머는 추상화에 의존, 구체화에 의존x
    
    → 구현 클래스에 의존하지 말고, 인터페이스에 의존해야됨
    
- 역할에 의존한다는 것과 같은 얘기 (ex. 앞에서 말했던 MemberService가 MemoryMemberRepository만 바라보고 다른 인터페이스는 몰라야 된다는 뜻)
- ex) 아까 자동차 얘기와도 같음
- 하지만 위 MemverService 코드 예시를 보면 인터페이스(추상호)에도 의존하고, 메모리 멤버 레파지토리(구체화)에도 의존하고 있음 - DIP 위반
- 다형성만으로 OCP, DIP 지킬 수 없음 → 뭔가 더 필요 → 스프링

### 리턴 투 스프링

- 스프링은 아래 기술로 위 문제를 해결( 다형성 + OCP,DIP를 가능하게 지원)
    - DI : 의존관계, 의존성 주입
    - DI 컨테이너 제공
- 클라이언트 코드 변경없이 기능 확장
- 부품 갈아끼우듯 개발