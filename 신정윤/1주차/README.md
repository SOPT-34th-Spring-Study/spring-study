## 🌱 섹션 1 - 객체 지향 설계와 스프링

---
### 👉 `1-1` 이야기 - 자바 진영의 추운 겨울과 스프링의 탄생

> JPA : 자바 ORM 표준 인터페이스
> - ORM이란, 객체와 데이터베이스를 매핑(클래스와 테이블)해주는 기술
>   - JPA 구현체 : _Hibernate, EclipseLink_

<br/>

### 👉 `1-2` 스프링이란?
![출처: 김영한 - 스프링 핵심 원리 - 기본편](https://velog.velcdn.com/images/hcu55/post/f2c0dccf-925b-4bf5-b2e5-ebca8457a9f4/image.png)

<br/>

📍 스프링 프레임워크 (~~_영한피셜 제일 중요하다고 함 .._~~)
> - 자바 플랫폼을 위한 오픈소스 어플리케이션 프레임워크로서 엔터프라이즈급 어플리케이션을 개발하기 위한 모든 기능을 종합적으로 제공하는 경량화된 솔루션이다.
>   - 🤔엔터프라이즈란급 개발이란?
>     - 대규모 데이터 처리와 트랜잭션이 동시에 여러 사용자로 부터 행해지는 매우 큰 규모의 환경을 엔터프라이즈 환경

- `핵심 기술`: 스프링 DI 컨테이너, AOP, 이벤트, 기타
- `웹 기술`: 스프링 MVC, 스프링 WebFlux
- `데이터 접근 기술`: 트랜잭션, JDBC, ORM 지원, XML 지원
- `기술 통합`: 캐시, 이메일, 원격접근, 스케줄링
- `테스트`: 스프링 기반 테스트 지원
- `언어`: 코틀린, 그루비 <br/>
_최근에는 스프링 부트를 통해서 스프링 프레임워크의 기술들을 편리하게 사용_

<br/>

📍 스프링 부트
- 스프링을 편리하게 사용할 수 있도록 지원, 최근에는 기본으로 사용
- 스프링과 3rd party(외부) 라이브러리 자동 구성
- Tomcat 같은 웹 서버를 내장해서 별도의 웹 서버를 설치하지 않아도 됨
    > Tomcat이란?
  > <br/> 
  > - 흔히 `WAS(Web Applicaton Server)`라고 말한다.
  > - dynamic(동적)인 웹을 만들기 위한 웹 컨테이너, 서블릿 컨테이너라고 불리며, 웹서버에서 정적으로 처리해야할 데이터를 제외한 JSP, ASP, PHP 등은 웹 컨테이너(톰캣)에게 전달한다.
  > - `동적인 데이터 처리`가 가능하고, DB연결, 데이터 조작, 다른 응용프로그램과 상호 작용이 가능하다. 
  > - `톰캣은 8080포트로 처리한다.`

<br/>

📍 스프링 단어?
- 스프링 DI 컨테이너 기술
- 스프링 프레임워크
- 스프링 부트, 스프링 프레임워크 등을 모두 포함한 스프링 생태계
<br/>

📍 스프링의 진짜 핵심 (~~_영한피셜... 모든 기술은 핵심 컨셉이 중요하다.._~~)
- 스프링은 자바 언어 기반의 프레임워크
- 자바 언어의 가장 큰 특징 - `객체 지향 언어`
- 스프링은 객체 지향 언어가 가진 강력한 특징을 살려내는 프레임워크
- 스프링은 좋은 객체 지향 애플리케이션을 개발할 수 있게 도와주는 프레임워크

<br/>

### 👉 `1-3` 좋은 객체 지향 프로그래밍이란?
📍객체 지향 프로그래밍

- 객체 지향 프로그래밍은 컴퓨터 프로그램을 명령어의 목록으로 보는 시각에서 벗어나 여러 개의 독립된 단위, 즉 "객체"들의 모임으로 파악하고자 하는 것이다. 각각의 객체는 메시지 를 주고받고, 데이터를 처리할 수 있다.(협력)
- 객체 지향 프로그래밍은 프로그램을 유연하고 변경이 용이하게 만들기 때문에 대규모 소프 트웨어 개발에 많이 사용된다.

📍객체 지향 특징 (`추상화`, `캡슐화`, `상속`, `다형성`)
> ✔️ 다형성
> - `역할`과 `구현`으로 세상을 구분.
>   - 역할 = `인터페이스`
>   - 구현 = `인터페이스를 구현한 클래스`, `구현 객체`
> - 장점
>   - 클라이언트(_예시 - 운전자_)는 대상의 역할(인터페이스)만 알면 된다. 
>     - 실제 구현 객체(~~로미오 역할을 누가 하는지..~~)는 몰라도 된다.
>   - 클라이언트는 구현 대상의 내부 구조를 몰라도 된다. 
>   - 클라이언트는 구현 대상의 내부 구조가 변경되어도 영향을 받지 않는다. 
>   - 클라이언트는 구현 대상 자체를 변경해도 영향을 받지 않는다. 
>   - `❗️인터페이스를 안정적으로 잘 설계하는 것이 중요❗️`
![자바에서의 다형성](https://velog.velcdn.com/images/hcu55/post/1052c95b-675c-4b4f-bbce-27e17cbe47a7/image.png)
>     - 자바에서의 다형성 : 같은 자료형에 여러가지 타입의 데이터를 대입하여 다양한 결과를 얻어낼 수 있는 성질


<br/>

### 👉 `1-4` 좋은 객체 지향 설계의 5가지 원칙(SOLID)
> 1️⃣ `SRP 단일 책임 원칙` <br/>
> : 한 클래스는 하나의 책임만 가져야 한다. (*책임이란 기능과 비슷한 의미)
> - `변경`이 있을때 파급효과가 적으면 단일 책임 원칠을 잘 따른 것
> - 예를 들어 A를 고쳤더니 B를 수정해야하고 또 C를 수정해야하고, C를 수정했더니 다시 A로 돌아가서 수정해야 하는, 마치 책임이 순환되는 형태를 만들지 말자. <br/>
    `출처`: https://inpa.tistory.com/entry/OOP-💠-아주-쉽게-이해하는-SRP-단일-책임-원칙 [Inpa Dev 👨‍💻:티스토리]

<br/>

> 2️⃣ `OCP 개방-폐쇄 원칙` (~~영한 피셜 가장 중요한 원칙 ..~~) <br/>
> : 소프트웨어 요소는 `확장`에는 열려 있으나, `변경`에는 닫혀있어야 한다.
> - 기존의 코드를 변경하지 않으면서, 기능을 추가할 수 있도록 설계
> - 🤔 변경에 닫혀있다?
>   - 객체를 직접적으로 수정하는 건 제한해야 한다는 것을 의미.
>   - 문제점
>     ```java
>     public class MemberService {
>          private MemberRepository memberRepository = new MemoryMemberRepository();
>          private MemberRepository memberRepository = new JdbcMemberRepository();
>     }
>     ```
>     - 구현 객체를 바꾸려면 클라이언트 코드를 변경해야 한다.
>     - 분명 다형성을 사용했지만, OCP 원칙을 지킬 수 없다.
>     - 👉 그럼 어떻게 해결?
>       - 스프링 컨테이너(_DI 컨테이너 등 필요, 추후 코드로 짜본다 하심_)
> 

<br/>

> 3️⃣ `LSP 리스코프 치환 원칙`
> : 프로그램 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.
> - `다형성`을 지원하기 위한 원칙
> - ex) 자식클래스가 오버라이딩 할 때 부모클래스의 의도와 다르게 맘대로 구현하면 안됨

<br/>

> 4️⃣ `ISP 인터페이스 분리 원칙`
> 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다
> - 인터페이스를 잘게 분리함으로써, 클라이언트의 목적과 용도에 적합한 인터페이스 만을 제공

<br/>

> 5️⃣ `DIP 의존관계 역전`
> : 구현 클래스에 의존하지 말고, 인터페이스에 의존하라
> - `클라이언트(운전자)`는 `역할(자동차)`만 알면되지, `구현객체(ex. k3)`는 몰라도 된다.

<br/>

> ✔️ `정리`
> - 객체 지향의 핵심은 `다형성`
> - 다형성 만으로는 쉽게 부품을 갈아 끼우듯이 개발할 수 없다.
> - 다형성 만으로는 구현 객체를 변경할 때 클라이언트 코드도 함께 변경된다.
> - 다형성 만으로는 OCP, DIP를 지킬 수 없다.
> - 뭔가 더 필요하다

<br/>

### 👉 `1-5` 객체 지향 설계와 스프링
> `정리`
> - 모든 설계에 `역할`과 `구현`을 분리하자.
>   - 자동차, 공연의 예를 떠올려보자.
>     - 애플리케이션 설계도 공연을 설계 하듯이 배역만 만들어두고, 배우는 언제든지 유연하게 변경할 수 있도록 만드는 것이 좋은 객체 지향 설계다.
> - 이상적으로는 모든 설계에 `인터페이스`를 부여하자
> > 🤔 `실무 고민`
> > - 하지만 `인터페이스`를 도입하면 추상화라는 비용이 발생한다.
> > - `기능을 확장`할 가능성이 없다면, `구체 클래스`를 직접 사용하고, 향후 꼭 필요할 때 `리팩토링`해서 `인터페이스`를 도입하는 것도 방법이다.
