## 섹션1. 객체 지향 설계와 스프링

---

<img width="1367" alt="Untitled" src="https://github.com/SOPT-34th-Spring-Study/spring-study/assets/125895298/910ecbad-5279-418f-9e37-02b4f75a8c03">

### 스프링이란?

자바 엔터프라이즈 애플리케이션 개발에 사용되는 애플리케이션 프레임워크

### 스프링의 핵심 기술

- 스프링 DI 컨테이너
- AOP
- 이벤트
- 기타

### 스프링 부트

- **스프링을 편리하게 사용할 수 있도록 지원, 최근에는 기본으로 사용**
- 단독으로 실행할 수 있는 스프링 애플리케이션을 쉽게 생성
- **Tomcat 같은 웹 서버를 내장해서 별도의 웹 서버를 설치하지 않아도 됨.**
- 손쉬운 빌드 구성을 위한 starter 종속성 제공
- 스프링과 3rd party(외부) 라이브러리 자동 구성
    - 유명한 메이저 라이브러리와 스프링 버전의 호환성을 확인해 맞는 버전을 자동으로 깔리도록 관리해 준다.
- 메트릭, 상태 확인, 외부 구성 같은 프로덕션 준비 기능 제공
    - 운영 환경에서 모니터링이 매우 중요한데, 이러한 부분을 스프링 부트가 기본적으로 제공해 준다.
- 관례에 의한 간결한 설정
    - 스프링만 사용하는 경우 설정이 굉장히 어려웠는데, 스프링 부트는 이런 설정을 간단하게 해결할 수 있도록 도와준다.

### 스프링 단어?

**문맥에 따라 다르게 사용!!**

1. 스프링 DI 컨테이너 기술
2. 스프링 프레임워크
3. 스프링 부트, 스프링 프레임워크 등을 모두 포함한 스프링 생태계

### 스프링의 본질적 핵심

- 스프링은 **좋은 객체 지향 애플리케이션을 개발할 수 있도록 개발자를 도와주는** 프레임워크

<aside>
💡 기존의 EJB를 사용하는 상황에서는 자바 본래의 객체 지향이 가진 장점들을 잃게 되었는데, EJB를 사용하면 EJB에 종속될 수밖에 없는 상황이 벌어졌다. 그래서 순수한 자바로 돌아가자 POJO라는 단어도 나왔었다!

</aside>

### 객체 지향 특징

- 추상화
- 캡슐화
- 상속
- 다형성

### 객체 지향 프로그래밍

- “객체”들의 모임으로 파악하고자 하는 것. 즉 각각의 객체는 메시지를 주고받고, 데이터를 처리할 수 있다.(협력)
- **프로그램을 유연하고 변경이 용이하게 만든다.**

### 유연하고 변경이 용이하다고?

- 컴포넌트를 쉽고 유연하게 변경하면서 개발을 할 수 있다는 뜻.
- **즉 다형성.**

### 다형성의 실세계 비유

- 실세계와 객체지향을 1:1로 매칭하는데 무리가 있음.
- 따라서 **역할**과 **구현**으로 세상을 구분

<img width="604" alt="Untitled 1" src="https://github.com/SOPT-34th-Spring-Study/spring-study/assets/125895298/514a363b-c975-4abf-90a4-47bed0bd4b00">

운전자 - 자동차

- 운전자(클라이언트)는 자동차 역할(인터페이스)에만 의존하고 있으므로, 자동차 구현체가 변경되어도 영향을 받지 않음.
- 새로운 자동차 구현체가 생겼거나, 자동차의 내부 구조와 구현 방식이 변경되었다 하더라도 운전자가 자동차 역할에 대한 이해만 있다면 운전이 가능.

  **→ 자동차 세상을 무한히 확장 가능**


공연 무대

- 로미오, 줄리엣과 연기하는 배우들로 역할과 구현을 나누어 놓았다면, 다른 배우(구현체)로 대체한다고 하더라도 공연 자체에는 무리가 없는 구조이다.

결론

- **역할과 구현을 분리하게 된다면, 클라이언트에 영향을 주지 않고, 새로운 기능을 제공할 수 있다. (즉 클라이언트를 바꿀 필요가 없다!)**
- **역할과 구현의 분리 → 유연하고 대체가 가능한 구조**

### 역할과 구현을 분리한다?

- 역할과 구현으로 구분하면, **세상이 단순해지고, 유연해지고, 변경이 편리해진다.**
- 장점
    - **클라이언트는 대상의 역할(인터페이스)만 알면된다.**
    - 클라이언트는 구현대상의 내부 구조를 몰라도 된다.
        - 자동차 디테일을 몰라도 운전자는 운전이 가능
    - 클라이언트는 구현대상의 내부 구조가 변경되어도 영향이 없다.
        - 기름차에서 전기차로 바꿔도 운전자는 운전이 가능
    - 클라이언트는 구현대상 자체를 변경해도 영향이 없다.
        - K3에서 테슬라로 바꿔도 운전자는 운전이 가능
- 단점
    - **역할(인터페이스) 자체가 변하면, 클라이언트와 서버 모두가 큰 변경이 필요해진다.**
    - 자동차를 비행기로 대체한다면??
    - 연극의 대본 자체가 변경된다면??
    - USB의 인터페이스가 변경된다면??
    - **인터페이스를 안정적으로 잘 설계하는 것이 매우 매우 중요하다**

### 역할과 구현의 분리

- 자바의 다형성을 활용
- **역할 = 인터페이스**
- **구현 = 인터페이스를 구현한 클래스, 구현 객체**
- 객체를 설계할 때 **역할**과 **구현**을 명확히 분리
- 객체 설계시 역할(인터페이스)를 먼저 부여하고, 그 역할을 수행하는 구현 객체를 만들기

### 객체의 협력이라는 관계부터 생각하라

- **혼자있는 객체는 없다.**
- 클라이언트 : 요청, 서버 : 응답
- **수많은 객체 클라이언트와 객체 서버는 서로 협력관계를 갖는다.**

### 자바의 다형성

- **오버라이딩된 메서드가 실행된다.**
- **다형성으로 인터페이스를 구현한 객체를 실행 시점에 유연하게 변경 가능!**
- 물론 클래스 상속관계도 다형성, 오버라이딩 가능

<img width="601" alt="Untitled 2" src="https://github.com/SOPT-34th-Spring-Study/spring-study/assets/125895298/85d89427-3eab-4d87-a060-8d2ecd1cad8d">

<aside>
💡 클라이언트(MemberService)는 MemberRepository에 의존(알고있다) 즉, 클라이언트는 역할(MemberRepository)을 알고있으므로 구현체가 MemoryMemberRepository → JdbcMemberRepository로 바뀌어도 클라이언트에 영향을 주지 않는다!

</aside>

### 다형성의 본질

- **클라이언트를 변경하지 않고, 서버의 구현 기능을 유연하게 변경할 수 있다.**
- **인터페이스를 구현한 객체 인스턴스를 실행 시점에 유연하게 변경이 가능**
- 다형성의 본질을 이해하려면 **협력**이라는 객체 사이의 관계에서 시작

### 다시 스프링과 객체지향에 대해

- **다형성이 가장 중요!**
- 스프링은 이러한 다형성을 극대화해서 이용할 수 있게 도와줌
- IoC, DI는 다형성을 이용해 역할과 구현을 편리하게 다룰 수 있도록 지원함

### SOLID

클린코드로 유명한 로버트 마틴의 좋은 객체 지향 설계의 5가지 원칙을 정리한 것

1. SRP : 단일 책임 원칙(Single Responsibility Principle)
2. OCP : 개방-폐쇄 원칙(Open/Closed Principle)
3. LSP : 리스코프 치환 원칙(Liskov substituion principle)
4. ISP : 인터페이스 분리 원칙(Interface segregation principle)
5. DIP : 의존관계 역전 원칙(Dependency inversion principle)

### SRP 단일 책임 원칙

- **한 클래스는 하나의 책임만 가져야 함**
- 그러면 하나의 책임이 뭔데??
    - 책임이 클 수도 있고, 작을 수도 있음
    - 문맥과 상황에 따라 다름
- **중요한 기준은 변경!**
    - 변경이 있을 때 파급효과가 적다면? → **SRP를 잘 따른 것!.**


### OCP 개방-폐쇄 원칙(가장중요)

- 소프트웨어 요소는 **확장에는 열려있으나, 변경에는 닫혀있어야 함(= 기존 코드를 수정하지 않아야 함)**
- 의문점 : 확장을 하려면, 당연히 기존코드를 변경해야 하지 않나?
- **다형성이 여기서 등장!**
- **인터페이스를 구현한 새로운 클래스를 만들어서 새로운 기능을 구현**
    - **이 방법은 기존 인터페이스 코드를 변경한 것이 아닌, 새로운 클래스를 만들어 확장을 한 것임.**
    - **역할과 구현의 분리가 여기서도 등장!**


**중요!**

<img width="659" alt="Untitled 3" src="https://github.com/SOPT-34th-Spring-Study/spring-study/assets/125895298/5f43c76e-f0de-4302-b078-0b03c75db0fb">

- MemberService(클라이언트)가 구현 클래스를 직접 선택
    - 근데 new MemoryMemberRepository()에서 new JdbcMemberRepository()로 **구현 객체를 변경할 때, 코드가 변경되지 않나? 이러면 OCP 안 지킨거 아니야?**
- **구현 객체를 변경할 때 클라이언트 코드를 변경해야 함**
    - **분명 다형성을 사용했지만 OCP 원칙을 지키지 못함!**
- 그러면 이 문제(OCP 원칙 지키지 x)를 어떻게 해결?
    - 객체를 생성, 연관관계 맺어주는 별도의 조립, 설정자가 필요
    - **Spring Framework는 Spring Container가 이 역할을 담당해줌!**

### LSP 리스코프 치환 원칙

- 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 함.
- **쉽게 말하면, 하위 클래스는 인터페이스 규약을 다 지켜야 한다는 것.**
    - 다형성을 지원하기 위한 원칙
    - 인터페이스를 구현한 구현체는 믿고 사용하려면, 이 원칙이 필요
- 단순히 컴파일에 성공하는 것을 넘어서는 이야기
- **ex) 자동차 인터페이스의 액셀 = 앞으로 가라는 기능, 뒤로 가게 구현하면 LSP를 위반하는 것!**

### ISP 인터페이스 분리 원칙

- 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다
- ex) 자동차 인터페이스 (운전 + 정비) → 운전 인터페이스, 정비 인터페이스로 분리

  ex) 사용자 클라이언트(운전자, 정비사) → 운전자 클라이언트, 정비사 클라이언트로 분리

    - 이렇게 분리하면 정비 인터페이스가 변해도, 운전자 클라이언트에 영향 없음
- 즉, **어떤** **구현 클래스는 자신이 구현하지 않는 인터페이스를 사용하지 않도록 인터페이스를 역할에 맞게 분리해야 한다!**

### DIP 의존 역전 원칙(중요)

- 프로그래머는 “추상화에 의존해야지, 구체화에 의존하면 안된다”
- 쉽게 말해서, **구현 클래스에 의존하지 말고 인터페이스(역할)에 의존해야 한다**는 말
- 앞에서부터 계속 이야기 한 **역할에 의존하게 해야 한다는 말과 같다.**
- 객체가 **인터페이스에 의존해야 유연하게 구현체를 변경 가능**, 반대로 **구현체에 의존하면 변경이 아주 어려움.**

<img width="659" alt="Untitled 3" src="https://github.com/SOPT-34th-Spring-Study/spring-study/assets/125895298/5f43c76e-f0de-4302-b078-0b03c75db0fb">

그런데! OCP에서 설명한 MemberService를 유심히 봐보자, **MemberRepository 인터페이스에 의존하지만, 동시에 구현클래스 MemoryMemberRepository에도 의존하고 있지 않는가?**

- MemberRepository m = new MemoryMemberRepository();
    - **MemberService(클라이언트)가 구현 클래스를 직접 선택해야 하는 상황.**
    - **따라서 코드를 변경해야 하므로 OCP를 위반했던 것!!**
    - **역시 추상화에도 의존하고, 구체화에도 의존하기에 DIP도 위반!!**

### 스프링과 OCP, DIP

- 스프링은 다음 기술들로 다형성 + OCP, DIP를 가능하게 지원
    - **DI(Dependency Injection) : 의존관계, 의존성 주입**
    - **DI 컨테이너 제공**
- **클라이언트 코드의 변경 없이 기능 확장**

### 정리

- **다형성 만으로는 구현 객체를 변경할 때 클라이언트 코드도 함께 변경된다**
    - **즉, 다형성 만으로 OCP, DIP를 지킬 수 없다!**
    - **이를 가능하게 해주는 게 스프링의 DI, DI 컨테이너이다.**
- 모든 설계에 역할과 구현을 분리하자
- 이상적으로 모든 설계에 인터페이스를 부여하자
    - 하지만 인터페이스를 도입하면 추상화라는 비용이 발생한다.
    - **기능을 확장할 가능성이 없다면, 구체 클래스 직접 사용하고, 향후 꼭 필요할 때 리팩터링 해서 인터페이스를 도입하는 것도 방법이다**